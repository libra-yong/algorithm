/*
约瑟夫问题 (经典算法大全的有问题，现已根正，注意博客园为根正)
说明:
据说着名犹太历史学家 Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中 ，
39个犹太人决定宁愿死也不要被敌人到 ， 于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人 开始报数，每报数到第3人
该人就必须自杀 ，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从，Josephus要他的
朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。

解法:
约瑟夫问题可用代数分析来求解，将这个问题扩大好了，假设现在您与m个朋友不幸参与了这个游戏，您要如何保护您与您的朋友？
只要画两个圆圈就可以让自己与朋友免于死亡游戏，这两个圆圈内圈是排列顺序，而外圈是自杀顺序，如下图所示:
图略 
使用程式来求解的话，只要将阵列当作环状来处理就可以了，在阵列中由计数1开始，每找到三个无资料区就填入一个计数，
直而计数达41为止，然后将阵列由索引1开始列出，就可以得知每个位置的自杀顺序，这就是约瑟夫排列，41个人而报数3的约
琴夫排列如下所示：
14 36 1 38 15 2 24 30 3 16 34 4 25 17 5 40 31 6 18 26 7 37 19 8 35 27 9 20 32 10 41 21 11 28 39 12 22 33 13 29 23
由上可知，最后一个自杀的是在第31个位置，而倒数第二个自杀的要排在第16个位置，之前的人都死光了，所以他们也就不知
道约琴夫与他的朋友并没有遵守游戏规则了.
*/

#include <stdio.h>
#include <stdlib.h>

#define N 41
#define M 3

int main(void)
{
	int man[N] = {0};
	int count = 1;
	int i = 0, pos = -1;
	int alive = 0;
	
	/*
	初始化死亡顺序，当数到3时退出do-while循环 ，依次设置死亡排列序号 1,2,3……41 
	*/ 
	while(count <= N){ 
		do{
			pos = (pos + 1) % N;
			if(man[pos] == 0){
				i++;
			}
			 
			if(i == M){
				i = 0;
				break;
			}
		}while(1);
		
		man[pos] = count;
		count++;
	}
	 
	printf("\n约瑟夫死亡排列顺序: ");
	for( i = 0; i < N; i++){
		printf("%d ", man[i]);
	}
	
	printf("\n\n你想让几个人存活 ?");
	scanf("%d", &alive);
	
//	printf("L表示存活位置，D表示死亡位置。");
	printf("\nL表示这 %d 人要放的位置: \n", alive);
	for(i = 0; i < N; i++){
		//死亡排列序号小于等于N-alive的死亡 
		if(man[i] <= N-alive){
			printf("D");
		}else if(man[i] > N-alive){
			printf("L");
		}
		
		if((i + 1) % 5 == 0){
			printf(" ");
		}
	}
	printf("\n");
	
	return 0;
}
